/**
 * Mock Token Generator
 * =====================
 * 
 * Generates Auth0-style JWT tokens for development purposes.
 * 
 * ⚠️ SECURITY WARNING ⚠️
 * These tokens are signed with the demo private key that's checked into
 * the repository. This is ONLY for educational purposes!
 * 
 * In production with real Auth0:
 * - Tokens are generated by Auth0 servers
 * - Private keys never leave Auth0's infrastructure
 * - You would NEVER have access to sign tokens client-side
 */

import { AUTH_CONFIG, PRIVATE_KEY } from 'shared';
import type { TokenPair, IDTokenClaims, AccessTokenClaims } from 'shared';

// ===========================================
// Mock Users
// ===========================================

export interface MockUser {
  sub: string;
  name: string;
  email: string;
  picture?: string;
}

export const MOCK_USERS: MockUser[] = [
  {
    sub: 'auth0|user001',
    name: 'Alice Developer',
    email: 'alice@example.com',
    picture: 'https://api.dicebear.com/7.x/avataaars/svg?seed=alice',
  },
  {
    sub: 'auth0|user002',
    name: 'Bob Tester',
    email: 'bob@example.com',
    picture: 'https://api.dicebear.com/7.x/avataaars/svg?seed=bob',
  },
  {
    sub: 'auth0|user003',
    name: 'Charlie Admin',
    email: 'charlie@example.com',
    picture: 'https://api.dicebear.com/7.x/avataaars/svg?seed=charlie',
  },
];

// ===========================================
// Token Generation (Client-Side - Demo Only!)
// ===========================================

/**
 * Generate mock Auth0-style tokens for a user.
 * 
 * ⚠️ In production, this would be done by Auth0 servers.
 * We're doing it client-side purely for demonstration.
 */
export function generateMockTokens(user: MockUser): TokenPair {
  const now = Math.floor(Date.now() / 1000);
  
  // ID Token claims (for user display)
  const idTokenClaims: IDTokenClaims = {
    // Standard claims
    iss: AUTH_CONFIG.ISSUER,
    sub: user.sub,
    aud: AUTH_CONFIG.WIDGET_CLIENT_ID,
    iat: now,
    exp: now + AUTH_CONFIG.ID_TOKEN_EXPIRY_SECONDS,
    // User profile claims
    name: user.name,
    email: user.email,
    picture: user.picture,
    email_verified: true,
  };
  
  // Access Token claims (for API authorization)
  const accessTokenClaims: AccessTokenClaims = {
    // Standard claims
    iss: AUTH_CONFIG.ISSUER,
    sub: user.sub,
    aud: AUTH_CONFIG.WIDGET_API_AUDIENCE,
    iat: now,
    exp: now + AUTH_CONFIG.ACCESS_TOKEN_EXPIRY_SECONDS,
    // Authorization claims
    scope: AUTH_CONFIG.DEFAULT_SCOPES,
    azp: AUTH_CONFIG.WIDGET_CLIENT_ID,
  };
  
  // Sign the tokens
  // NOTE: We're using a simple base64 encoding here for the browser.
  // The actual RS256 signing happens on the host app side.
  // For standalone mode, we create "fake" tokens that the backend
  // will accept because they use the same key.
  
  const idToken = createJWT(idTokenClaims);
  const accessToken = createJWT(accessTokenClaims);
  
  return {
    access_token: accessToken,
    id_token: idToken,
    token_type: 'Bearer',
    expires_in: AUTH_CONFIG.ACCESS_TOKEN_EXPIRY_SECONDS,
  };
}

/**
 * Create a JWT token (simplified for browser - demo only).
 * 
 * In a real app, JWT signing with RS256 would require:
 * - Node.js crypto or WebCrypto API
 * - Proper PKCS#8 key parsing
 * 
 * For this demo, we'll create tokens that work with our backend
 * by using a simplified approach that still demonstrates the structure.
 */
function createJWT(payload: IDTokenClaims | AccessTokenClaims): string {
  // JWT header for RS256
  const header = {
    alg: 'RS256',
    typ: 'JWT',
    kid: AUTH_CONFIG.KEY_ID,
  };
  
  // Encode header and payload
  const encodedHeader = base64UrlEncode(JSON.stringify(header));
  const encodedPayload = base64UrlEncode(JSON.stringify(payload));
  
  // For browser compatibility in this demo, we'll use a placeholder signature.
  // The host app (which runs in Node.js) will generate real signatures.
  // This is just for displaying the token structure in dev mode.
  
  // Create a "fake" signature that's just for structure demonstration
  // The actual signing will be done by the host app
  const signatureInput = `${encodedHeader}.${encodedPayload}`;
  const fakeSignature = base64UrlEncode(
    `DEMO_SIGNATURE_${hashCode(signatureInput + PRIVATE_KEY.substring(0, 50))}`
  );
  
  return `${encodedHeader}.${encodedPayload}.${fakeSignature}`;
}

/**
 * Base64URL encode a string
 */
function base64UrlEncode(str: string): string {
  const base64 = btoa(unescape(encodeURIComponent(str)));
  return base64
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/, '');
}

/**
 * Simple hash code for demo signature
 */
function hashCode(str: string): string {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return Math.abs(hash).toString(36);
}

